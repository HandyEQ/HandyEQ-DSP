%   ------ Optimal IIR generator by Carl-Johan Haell ------
%   Rev. 4th April 2014
%   To-do: Make generic controls
%          Make scaling binaries
%
%   ------ Specification for first IIR ---- %
%   Passband frequency edge: 15kHz
%   Stopband frequency edge: 100kHz
%   Passband ripple: 0.5 dB
%   Stopband attenuation: 80 dB
%   Sample frequency: 768kHz
%   ----------------------------------------%

% ------ Control of the script -----%
GenerateGraphs = false;
GenerateVHDLfile = true;
GenerateReports = true;

% ------ Setting the spec ----- %

% Makes the design lowpass and creates the filter
Fs = 768; %kHz
Fb = 15; %kHz
Fstop = 100; %kHz
Fp =(2*Fb)/Fs; %Passband freq (x*pi) (Normalized)
Fst = (2*Fstop)/Fs; %Stopband freq (y*pi) (Normalized)
Ap = 0.5; %Passband ripple
Ast = 85; %Stopband attenuation
N = 2; % Order of the filter

% ------ 

%f = fdesign.lowpass('Fp,Fst,Ap,Ast',Fp,Fst,Ap,Ast); Works, no order tho
%f = fdesign.lowpass('N,Fst,Ap,Ast',N,Fst,Ap,Ast); %'N,Fst,Ap,Ast' * Not
%working
%f = fdesign.lowpass('N,Fst,Ast',N,Fst,Ast); % 'N,Fst,Ast' Not working
%f = fdesign.lowpass('N,Fp,Fst,Ast',N,Fp,Fst,Ast); %'N,Fp,Fst,Ast' * Not
%working
%f = fdesign.lowpass('N,Fp,Ap,Ast',N,Fp,Ap,Ast); %'N,Fp,Ap,Ast' NW

% --------- Working design -------- %
f = fdesign.lowpass('N,Fp,Ap',N,Fp,Ap); %'N,Fp,Ap' Working
% ---------------------------------%

Hdf1sos = design(f, 'cheby1', 'FilterStructure', 'df1sos');

[b,a] = tf(Hdf1sos);
Hdf1 = dfilt.df1(b,a);

% ------------------------------ %

% --------------- Creating the coeffiecients for the transfer function %
Hdf1.Arithmetic = 'fixed';
hfvt = fvtool(Hdf1,'legend','on');
legend(hfvt,'Direct-Form I')


Hdf1sos.Arithmetic = 'fixed';
setfilter(hfvt,Hdf1sos);
axis([0 1 -120 5])
legend(hfvt,'Direct-Form I SOS', 'Location','NorthEast')

rng(5,'twister');
q = quantizer([10,9],'RoundMode','round');
xq = randquant(q,1000,1);
x = fi(xq,true,10,9);

Hdf1sos.AccumWordLength = Hdf1sos.ProductWordLength;

fi1=fipref('NumberDisplay','bin','LoggingMode', 'on', 'DataTypeOverride', 'ScaledDoubles');
y = filter(Hdf1sos,x);
fi2=fipref('NumberDisplay','bin','LoggingMode', 'off', 'DataTypeOverride', 'ForceOff');

if GenerateReports
    R = qreport(Hdf1sos)
end;

Hdf1sos = design(f, 'cheby1', 'FilterStructure', 'df1sos', ...
    'SOSScaleNorm','Linf');

%   --- Set set coefficient word length and fractional length -------
Hdf1sos.Arithmetic = 'fixed';
Hdf1sos.ProductWordLength=32; %Leker, ta bort om fel
Hdf1sos.AccumWordLength=32; %Leker, ta bort om fel
Hdf1sos.InputWordLength=18; %samma
Hdf1sos.InputFracLength=17; %samma
Hdf1sos.OutputWordLength=18; %samma
%Hdf1sos.OutputFracLength=17; %samma
Hdf1sos.CoeffWordLength = 32;
Hdf1sos.ScaleValueFracLength = 31;

%Hdf1sos.AccumWordLength= Hdf1sos.ProductWordLength;
fipref('LoggingMode', 'on', 'DataTypeOverride', 'ScaledDoubles');
y = filter(Hdf1sos,x);
fipref('LoggingMode', 'off', 'DataTypeOverride', 'ForceOff');

if GenerateReports
    R = qreport(Hdf1sos)
end;

Hdf1sosf = autoscale(Hdf1sos,x);
Hdf1sosf.OutputFracLength=17; %samma

fipref('LoggingMode', 'on', 'DataTypeOverride', 'ForceOff');
y = filter(Hdf1sosf,x);
fipref('LoggingMode', 'off');

if GenerateReports
    R = qreport(Hdf1sosf)
end;

Hdf1sosf.OutputFracLength=17; %samma
close(hfvt);

if GenerateGraphs
    fvtool(Hdf1sosf,'Analysis','magestimate');
    fvtool(Hdf1sosf,'Analysis','noisepower');
end;

%   ---------- Generate coefficient package ----------- %

%   F?rsta tre coefficienterna ?r b_0 till b_2, sedan a_0 till a_2


Range = 1; % Indicates from which range the data is represented, +- Range

%   --------------------------------------------------------------


if GenerateVHDLfile
    
    fileID = fopen('IIRCoeffs.vhd','w');
    
    %Header
fprintf(fileID,'-- IIRCoeffs.vhd\n');
fprintf(fileID,'-- VHDL package holding LP IIR filter coefficients\n');
fprintf(fileID,'-- Carl-Johan Haell - Chalmers University of Technology\n\n');

fprintf(fileID,'-- Autogenerated file. Generated by "SpectoFixed.m"\n');
fprintf(fileID,'-- Generated: ');
fprintf(fileID,'                  ');
fprintf(fileID,datestr(now,'dd mmmm yyyy HH:MM:SS\n'));
fprintf(fileID,'-- Filter order (N)             %d\n',N);
fprintf(fileID,'-- Sample frequency (fs)        %dkHz : \n',Fs);
fprintf(fileID,'-- Cutoff frequency (fc)        %dkHz : \n',Fb);
fprintf(fileID,'-- Fractional binary format:    %d.%d \n', (Hdf1sosf.CoeffWordLength - Hdf1sosf.ScaleValueFracLength),Hdf1sosf.ScaleValueFracLength);
fprintf(fileID,'-- Stable (1/0)                 %d:\n\n',isstable(Hdf1sosf));

%Library
fprintf(fileID,'library ieee;\n');
fprintf(fileID,'use ieee.std_logic_1164.all; \n\n');
%Package
fprintf(fileID,'package IIR_coeffs is  \n');

Counter = 1;
for s = 1:3;
    
    a = fi([Hdf1sosf.sosMatrix(Counter)],Range,Hdf1sosf.CoeffWordLength,Hdf1sosf.ScaleValueFracLength); % Converts to desired format, 16bit Word, 15 bit coefs, 1 bit rep of signed.
    z = a.bin;
   
    fprintf(fileID,'constant Coeff_b%d : std_logic_vector(%d downto 0) := B"%s"; --b%d = %d\n', (Counter-1),(Hdf1sosf.CoeffWordLength-1),num2str(z),(Counter-1),Hdf1sosf.sosMatrix(Counter));
    
    Counter=Counter+1;
end

Counter = 2;
for s = 2:3; %Skips a0, because this is always 1.
    
     a = fi([Hdf1sosf.sosMatrix(Counter+3)],Range,Hdf1sosf.CoeffWordLength,Hdf1sosf.ScaleValueFracLength);  % Converts to desired format, 16bit Word, 15 bit coefs, 1 bit rep of signed.
    z = a.bin;
   
    X = fprintf(fileID,'constant Coeff_a%d : std_logic_vector(%d downto 0) := B"%s"; --a%d = %d\n', (Counter-1),(Hdf1sosf.CoeffWordLength-1),num2str(z),(Counter-1),Hdf1sosf.sosMatrix(Counter+3));

    
    Counter=Counter+1;
end

Counter = 1;
for s = 1:2; % Reads the scaling values and converts to binaries, ScaleValues_0 = Input, ScaleValues_1 = Output
    
    a = fi([Hdf1sosf.ScaleValues(Counter)],Range,Hdf1sosf.InputWordLength,Hdf1sosf.InputFracLength);  % Converts to desired format, 16bit Word, 15 bit coefs, 1 bit rep of signed.
    z = a.bin;
   
    X = fprintf(fileID,'constant ScaleValue_%d : std_logic_vector(%d downto 0) := B"%s"; --ScaleValue_%d = %d\n', (Counter-1),(Hdf1sosf.InputWordLength-1),num2str(z),(Counter-1),Hdf1sosf.ScaleValues(Counter));

    
    Counter=Counter+1;
end


%-- define each pre gain sample flip flop
%	signal ZFF_X0, ZFF_X1, ZFF_X2, ZFF_Y1, ZFF_Y2 : std_logic_vector(17 downto 0) := (others => '0');
% Hdf1sosf.ScaleValues
% define each post gain 32 but truncated sample
%	signal pgZFF_X0, pgZFF_X1, pgZFF_X2, pgZFF_Y1, pgZFF_Y2 : std_logic_vector(17 downto 0) := (others => '0');

fprintf(fileID,'end IIR_coeffs; \n\n');

fprintf(fileID,' \n');

fclose(fileID);
end

